# Noise Extension: Disco

* author:     David Wong (david.wong@nccgroup.trust)
* revision:   `1draft-1`
* date:       2017-07-20

## 1. Motivation

Noise is a framework for crypto protocols based on Diffie-Hellman key agreement. One of its most interesting property is that every new message depends on all the previous ones. This is done by continuously hashing messages being sent and received, as well as continuously deriving new keys based on the continuous hash and the previous keys. This interesting property stops at the end of the handshake.
Strobe is a protocol framework based on a duplex construction, which naturally benefits from the same properties. The Strobe specification is comparable to Noise while focusing on the symmetric part of a protocol. By merging both protocols into Disco, the following goals can be achieved:

* The Noise specification can be greatly simplified by removing all the symmetric cryptographic algorithms and symmetric objects. These can be replaced by a single Strobe object.
* Implementations of Noise with the Disco extension will consequently greatly benefit from this simplification, allowing for a drastic reduction of the codebase, facilitating security audits.
* Messages will continue to rely on every previous messages that were sent or received, even in the symmetric part of the protocol.
* The Strobe functions will allow for more flexible and complex symmetric protocols following the handshake.
* Implementations of Noise with the Disco extension will also benefit from the other Strobe functions, which provide on top of a single primitive the following functions: generation of random numbers, derivation of keys, hashing, encryption and authentication.

## 2. Major changes

* Protocol names don't have the symmetric algorithms, but instead the version of Strobe.
* The SymmetricState and CipherState objects have been removed.
* The Handshake object make calls to Strobe functions.
* The Handshake returns two Strobe states.

## 3. Protocol naming

The protocol name starts by following the same convention of Noise, but stops at the declaration of the symmetric cryptographic algorithms. The rest is effectively replaced by the version of Strobe in use.

```
Noise_[PATTERN]_[KEYEXCHANGE]_STROBEvX.Y.Z
```

Note: the current version of [Strobe](https://strobe.sourceforge.io/) is STROBEv1.0.2

<!-- maybe change this to Noise_[PATTERN]_[KEYEXCHANGE]_STROBEvX.Y.Z_PERMUTATION -->

# 4. The StrobeState Object

## 4.1. Variables

* **`R`**: The rate of Strobe (computed as N - (2*sec)/8 - 2)
* **`TAGLEN`** = A constant specifying the size in bytes of the authentication tags generated by `SEND_AEAD`. For security reasons, `TAGLEN` must be 16 or greater.

## 4.2. Functions

A StrobeState, implemented according to the [Strobe specification](https://strobe.sourceforge.io/) responds to the following functions:

**`InitializeStrobe(protocol_name)`**: Initialize the Strobe object with
   a custom protocol name.

**`KEY(key)`**:
   Replaces the Strobe's state with the key.

**`PRF(output_len)`**:
   Removes `output_len` bytes from the Strobe's state and outputs them to the
   caller.

**`Send_ENC(plaintext)`**:
   XOR the plaintext with the Strobe's state. The Strobe's state is replaced by
   the resulting ciphertext. This outputs the ciphertext to the caller as well.

**`Recv_ENC(ciphertext)`**:
   XOR the ciphertext with the Strobe's state. The Strobe's state is replaced
   by the ciphertext, while the resulting plaintext is output to the caller.

**`AD(additionalData)`**:
   XOR the additional data in the Strobe's state.

**`Send_CLR(cleartext)`**:
   XOR the cleartext in the Strobe's state.

**`Recv_CLR(cleartext)`**:
   XOR the cleartext in the Strobe's state.

**`Send_MAC(output_length)`**:
   Retrieves the next `output_length` bytes from the Strobe's state.

**`Recv_MAC(tag)`**:
   Compare in constant-time the received tag with the next `len(tag)` bytes
   from the Strobe's state.

**`RATCHET(length)`**:
   Set the next `length` bytes from the Strobe's state to zero.

the following meta functions:

**`Send_meta_ENC(plaintext)`**:
   encrypting framing data

**`Recv_meta_ENC(ciphertext)`**:
   XOR the ciphertext with the Strobe's state. The Strobe's state is replaced
   by the ciphertext, while the resulting plaintext is output to the caller.

**`meta_AD(additionalData)`**:
   XOR the additional data in the Strobe's state.

**`Send_meta_CLR(cleartext)`**:
   XOR the cleartext in the Strobe's state.

**`Recv_meta_CLR(cleartext)`**:
   XOR the cleartext in the Strobe's state.

**`Send_meta_MAC(output_length)`**:
   Retrieves the next `output_length` bytes from the Strobe's state.

**`Recv_meta_MAC(tag)`**:
   Compare in constant-time the received tag with the next `len(tag)` bytes
   from the Strobe's state.

and the following two functions not specified in Strobe:

**`Send_AEAD(plaintext, ad)`**:
   Combines `SEND_ENC` followed with `SEND_MAC(TAGLEN)`.

**`Recv_AEAD(ciphertext, ad)`**:
   Combines `RECV_ENC` followed with `RECV_MAC(TAGLEN)`.


# 5. Modifications to the HandshakeState

A `HandshakeState` object contains a `StrobeState` plus the following
variables, any of which may be `empty`.  `Empty` is a special value which
indicates the variable has not yet been initialized.

* **`s`**: The local static key pair
* **`e`**: The local ephemeral key pair
* **`rs`**: The remote party's static public key
* **`re`**: The remote party's ephemeral public key

A `HandshakeState` also has variables to track its role, and the remaining
portion of the handshake pattern:

* **`initiator`**: A boolean indicating the initiator or responder role.
* **`message_patterns`**: A sequence of message patterns.  Each message
    pattern is a sequence of tokens from the set `("e", "s", "ee", "es", "se",
    "ss")`.  (An additional `"psk"` token is introduced in [Section
    9](pre-shared-symmetric-keys), but we defer its explanation until then.)

A `HandshakeState` responds to the following functions:

**`Initialize(handshake_pattern, initiator, prologue, s, e, rs, re)`**:

Takes a valid `handshake_pattern` (see [Section 7](#handshake-patterns)) and an `initiator` boolean specifying this party's role as either initiator or responder.

Takes a `prologue` byte sequence which may be zero-length, or which may contain context information that both parties want to confirm is identical (see [Section 6](#prologue)).

Takes a set of DH key pairs `(s, e)` and public keys `(rs, re)` for initializing local variables, any of which may be empty.
Public keys are only passed in if the `handshake_pattern` uses pre-messages (see [Section 7](#handshake-patterns)).The ephemeral values `(e, re)` are typically left empty, since they are created and exchanged during the handshake; but there are exceptions (see [Section 10.1](fallback-patterns)).

Performs the following steps:

* Derives a `protocol_name` byte sequence by combining the names for the handshake pattern and crypto functions, as specified in [Section 8](#protocol-names). Calls `InitializeStrobe(protocol_name)`.
* Calls `AD(prologue)`.
* Sets the `initiator`, `s`, `e`, `rs`, and `re` variables to the corresponding arguments.
* Calls `AD()` once for each public key listed in the pre-messages from `handshake_pattern`, with the specified public key as input (see [Section 7](#handshake-patterns) for an explanation of pre-messages). If both initiator and responder have pre-messages, the initiator's public keys are hashed first.
* Sets `message_patterns` to the message patterns from `handshake_pattern`.

**`WriteMessage(payload, message_buffer)`**: Takes a `payload` byte sequence which may be zero-length, and a `message_buffer` to write the output into.  Performs the following steps:

* Fetches and deletes the next message pattern from `message_patterns`, then sequentially processes each token from the message pattern:
    - For `"e"`:  Sets `e = GENERATE_KEYPAIR()`.  Appends `e.public_key` to the buffer.  Calls `AD(e.public_key)`.
    - For `"s"`:  Appends `SEND_AEAD(s.public_key)` to the buffer.  
    - For `"ee"`: Calls `AD(DH(e, re))`.
    - For `"es"`: Calls `AD(DH(e, rs))` if initiator, `AD(DH(s, re))` if responder.
    - For `"se"`: Calls `AD(DH(s, re))` if initiator, `AD(DH(e, rs))` if responder.
    - For `"ss"`: Calls `AD(DH(s, rs))`.
* Appends `SEND_ENC(payload)` to the buffer.  
* If there are no more message patterns returns two new `StrobeState` objects by calling `Split()`.

**`ReadMessage(message, payload_buffer)`**: Takes a byte sequence containing a Disco handshake message, and a `payload_buffer` to write the message's plaintext payload into.  Performs the following steps:

* Fetches and deletes the next message pattern from `message_patterns`, then sequentially processes each token from the message pattern:
    - For `"e"`: Sets `re` to the next `DHLEN` bytes from the message. Calls `AD(re.public_key)`.
    - For `"s"`: Sets `temp` to the next `DHLEN + 16` bytes of the message. Sets `rs` to `Recv_AEAD(temp)`.  
    - For `"ee"`: Calls `AD(DH(e, re))`.
    - For `"es"`: Calls `AD(DH(e, rs))` if initiator, `AD(DH(s, re))` if responder.
    - For `"se"`: Calls `AD(DH(s, re))` if initiator, `AD(DH(e, rs))` if responder.
    - For `"ss"`: Calls `AD(DH(s, rs))`.
* Calls `Recv_AEAD()` on the remaining bytes of the message and stores the output into `payload_buffer`.
* If there are no more message patterns returns two new `StrobeState` objects by calling `Split()`.

**`Split()`**: Returns a pair of StrobeState objects for encrypting transport messages. Executes the following steps:

* Sets `s1 = StrobeState` and `s2 = Clone(StrobeState)`.
* Calls `AD_meta("initiator")` with `s1` and `AD_meta("responder")` with `s2`.
* Calls `RATCHET(R)` with `s1` and with `s2`.
* Returns the pair (`s1`, `s2`).

**`Clone(strobe_state)`**: Returns a copy of the `strobe_state`.






