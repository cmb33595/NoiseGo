# Noise Extension: Disco

* author:     David Wong (david.wong@nccgroup.trust)
* revision:   `disco-draft-1`
* extending:  `noise-revision-32`
* date:       2017-07-20

## 1. Introduction

### 1.1. Motivation

[Noise](http://noiseprotocol.org/) is a framework for crypto protocols based on Diffie-Hellman key agreement. One of its most interesting property is that every new message depends on all the previous ones. This is done by continuously hashing messages being sent and received, as well as continuously deriving new keys based on the continuous hash and the previous keys. This interesting property stops at the end of the handshake.  
[Strobe](http://strobe.sourceforge.io/) is a protocol framework based on a [duplex construction](http://sponge.noekeon.org/). It naturally benefits from the same property, effectivelly absorbing every operation to influence the next ones. The Strobe specification is comparable to Noise, while focusing on the symmetric part of a protocol. By merging both protocols into one, Disco achieves the following goals:

* The Noise specification can be greatly simplified by removing all the symmetric cryptographic algorithms and symmetric objects. These can be replaced by a single Strobe object.
* Implementations of Noise with the Disco extension will consequently greatly benefit from this simplification, allowing for a drastic reduction of the codebase, facilitating security audits.
* Messages will continue to rely on every previous messages that were sent or received, even in the symmetric part of the protocol.
* The Strobe functions will allow for more flexible and complex symmetric protocols following the handshake.
* Implementations of Noise with the Disco extension will also benefit from the other Strobe functions, which provide on top of a single primitive the following functions: generation of random numbers, derivation of keys, hashing, encryption and authentication.

### 1.2. How to Read This Document

This specification is an extension of the Noise protocol framework revision 32. It relies for the most part on Noise's specification, while heavily modifying its foundations. Major changes are listed in the next section.  
To implement the Disco extension, a Strobe implementation respecting the functions of the [section 3.2 of this document](#3-2-functions) is required. None of the [cryptographic algorithms of Noise](http://noiseprotocol.org/noise.html#crypto-functions) are required. Furthermore, neither the [CipherState](http://noiseprotocol.org/noise.html#the-cipherstate-object) or the [SymmetricState](http://noiseprotocol.org/noise.html#the-symmetricstate-object) object are necessary. When implementing Noise with the Disco extension, simply implement the HandshakeState object following the changes described in [section 4 of this document](#-4-modifications-to-the-handshakestate). For pre-shared symmetric keys, refer to [section 5](#5-modifications-to-pre-shared-symmetric-key); for advanced features, refer to [section 6](#6-modifications-to-advanced-features).

### 1.3. Major changes

The following list summarizes the major changes brought by this extension:

* Protocol names don't have the symmetric algorithms, but instead the version of Strobe.
* The SymmetricState and CipherState objects have been removed.
* The Handshake object make calls to Strobe functions.
* The Handshake returns two Strobe states.

## 2. Protocol naming

The name of a Noise protocol extended with Disco starts by following the same convention, but stops at the declaration of the symmetric cryptographic algorithms. These are effectively replaced by the version of Strobe in use.

```
Noise_[PATTERN]_[KEYEXCHANGE]_STROBEvX.Y.Z
```

For example, with the current version of [Strobe](https://strobe.sourceforge.io/) being STROBEv1.0.2:

```
Noise_XX_25519_STROBEv1.0.2
```

<!-- TODO: maybe change this to Noise_[PATTERN]_[KEYEXCHANGE]_STROBEvX.Y.Z_PERMUTATION -->

## 3. The StrobeState Object

### 3.1. Variables

* **`R`**: The rate of Strobe (computed as N - (2*sec)/8 - 2)
* **`TAGLEN`** = A constant specifying the size in bytes of the authentication tags generated by `SEND_AEAD`. For security reasons, `TAGLEN` must be 16 or greater.

### 3.2. Functions

A StrobeState is litteraly the state of a Strobe duplex construction. While it responds to many functions ([see Strobe's specification](https://strobe.sourceforge.io/)), only the following ones need to be implemented in order for the Disco extension to work properly:

**`InitializeStrobe(protocol_name)`**: Initialize the Strobe object with
   a custom protocol name.

**`KEY(key)`**:
   Replaces the Strobe's state with the key.

**`PRF(output_len)`**:
   Removes `output_len` bytes from the Strobe's state and outputs them to the
   caller.

**`Send_ENC(plaintext)`**:
   XOR the plaintext with the Strobe's state. The Strobe's state is replaced by
   the resulting ciphertext. This outputs the ciphertext to the caller as well.

**`Recv_ENC(ciphertext)`**:
   XOR the ciphertext with the Strobe's state. The Strobe's state is replaced
   by the ciphertext, while the resulting plaintext is output to the caller.

**`AD(additionalData)`**:
   XOR the additional data in the Strobe's state.

**`Send_MAC(output_length)`**:
   Retrieves the next `output_length` bytes from the Strobe's state.

**`Recv_MAC(tag)`**:
   Compare in constant-time the received tag with the next `len(tag)` bytes
   from the Strobe's state.

**`RATCHET(length)`**:
   Set the next `length` bytes from the Strobe's state to zero.

the following meta functions:

**`meta_AD(additionalData)`**:
   XOR the additional data in the Strobe's state.

and the following two functions which are not specified in Strobe:

**`Send_AEAD(plaintext, ad)`**:
   Combines `SEND_ENC` followed with `SEND_MAC(TAGLEN)`.

**`Recv_AEAD(ciphertext, ad)`**:
   Combines `RECV_ENC` followed with `RECV_MAC(TAGLEN)`.


## 4. Modifications to the HandshakeState

The handshakeState object can be implemented following Noise's specification, except for the following points:

A `HandshakeState` object contains a `StrobeState` in place of the `SymmetricState`.

All functions responding to a handshakeState have been modified. The following modifications only affect the algorithms, for more information refer to [section 5.3 of the Noise specification](http://noiseprotocol.org/noise.html#the-handshakestate-object).

**`Initialize(handshake_pattern, initiator, prologue, s, e, rs, re)`**: 

* Derives a `protocol_name` byte sequence by combining the names for the handshake pattern and crypto functions, as specified in [Section 2 of this document](#2-protocol-naming). Calls `InitializeStrobe(protocol_name)`.
* Calls `AD(prologue)`.
* Sets the `initiator`, `s`, `e`, `rs`, and `re` variables to the corresponding arguments.
* Calls `AD()` once for each public key listed in the pre-messages from `handshake_pattern`, with the specified public key as input. If both initiator and responder have pre-messages, the initiator's public keys are hashed first.
* Sets `message_patterns` to the message patterns from `handshake_pattern`.

**`WriteMessage(payload, message_buffer)`**: 

* Fetches and deletes the next message pattern from `message_patterns`, then sequentially processes each token from the message pattern:
    - For `"e"`:  Sets `e = GENERATE_KEYPAIR()`.  Appends `e.public_key` to the buffer.  Calls `AD(e.public_key)`.
    - For `"s"`:  Appends `SEND_AEAD(s.public_key)` to the buffer.  
    - For `"ee"`: Calls `AD(DH(e, re))`.
    - For `"es"`: Calls `AD(DH(e, rs))` if initiator, `AD(DH(s, re))` if responder.
    - For `"se"`: Calls `AD(DH(s, re))` if initiator, `AD(DH(e, rs))` if responder.
    - For `"ss"`: Calls `AD(DH(s, rs))`.
* Appends `SEND_ENC(payload)` to the buffer.  
* If there are no more message patterns returns two new `StrobeState` objects by calling `Split()`.

**`ReadMessage(message, payload_buffer)`**: 

* Fetches and deletes the next message pattern from `message_patterns`, then sequentially processes each token from the message pattern:
    - For `"e"`: Sets `re` to the next `DHLEN` bytes from the message. Calls `AD(re.public_key)`.
    - For `"s"`: Sets `temp` to the next `DHLEN + 16` bytes of the message. Sets `rs` to `Recv_AEAD(temp)`.  
    - For `"ee"`: Calls `AD(DH(e, re))`.
    - For `"es"`: Calls `AD(DH(e, rs))` if initiator, `AD(DH(s, re))` if responder.
    - For `"se"`: Calls `AD(DH(s, re))` if initiator, `AD(DH(e, rs))` if responder.
    - For `"ss"`: Calls `AD(DH(s, rs))`.
* Calls `Recv_AEAD()` on the remaining bytes of the message and stores the output into `payload_buffer`.
* If there are no more message patterns returns two new `StrobeState` objects by calling `Split()`.

**`Split()`**: Returns a pair of StrobeState objects for encrypting transport messages. Executes the following steps:

* Sets `s1 = StrobeState` and `s2 = Clone(StrobeState)`.
* Calls `meta_AD("initiator")` with `s1` and `meta_AD("responder")` with `s2`.
* Calls `RATCHET(R)` with `s1` and with `s2`.
* Returns the pair (`s1`, `s2`).

**`Clone(strobe_state)`**: Returns a copy of the `strobe_state`.

## 5. Modifications to Pre-shared Symmetric Key 

PSK mode can use the `KEY()` function (instead of the original `MixKeyAndHash()` function) to mix the PSK into the Strobe state.

<!-- does this need more information? -->

## 6. Modifications to Advanced Features

### 6.1 Channel Binding

Right before calling `Split()`, a binding value could be obtained from the StrobeState by calling `PRF()`.

### 6.2 Rekey

To enable this, Strobe supports a `RATCHET()` function.

## 7. Security Considerations

The same security considerations that apply to Noise and Strobe are to be considered.


