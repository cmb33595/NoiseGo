# Noise Extension: Disco

* author:     David Wong (david.wong@nccgroup.trust)
* revision:   `disco-draft-1`
* extending:  `noise-revision-32`
* date:       2017-07-20

## 1. Introduction

### 1.1. Motivation

[Noise](http://noiseprotocol.org/) is a framework for crypto protocols based on Diffie-Hellman key agreement. One of its most interesting property is that every new message depends on all the previous ones. This is done by continuously hashing messages being sent and received, as well as continuously deriving new keys based on the continuous hash and the previous keys. This interesting property stops at the end of the handshake.  
[Strobe](http://strobe.sourceforge.io/) is a protocol framework based on a [duplex construction](http://sponge.noekeon.org/). It naturally benefits from the same property, effectivelly absorbing every operation to influence the next ones. The Strobe specification is comparable to Noise, while focusing on the symmetric part of a protocol. By merging both protocols into one, Disco achieves the following goals:

* The Noise specification can be greatly simplified by removing all the symmetric cryptographic algorithms and symmetric objects. These can be replaced by a single Strobe object.
* Implementations of Noise with the Disco extension will consequently greatly benefit from this simplification, allowing for a drastic reduction of the codebase, facilitating security audits.
* Messages will continue to rely on every previous messages that were sent or received, even in the symmetric part of the protocol.
* The Strobe functions will allow for more flexible and complex symmetric protocols following the handshake.
* Implementations of Noise with the Disco extension will also benefit from the other Strobe functions, which provide on top of a single primitive the following functions: generation of random numbers, derivation of keys, hashing, encryption and authentication.

### 1.2. How to Read This Document

This specification is an extension of the Noise protocol framework revision 32. It relies for the most part on Noise's specification, while heavily modifying its foundations. Major changes are listed in the next section.  
To implement the Disco extension, a Strobe implementation respecting the functions of the [section 3.2 of this document](#3-2-functions) is required. None of the [cryptographic algorithms of Noise](http://noiseprotocol.org/noise.html#crypto-functions) are required. Furthermore, neither the [CipherState](http://noiseprotocol.org/noise.html#the-cipherstate-object) or the [SymmetricState](http://noiseprotocol.org/noise.html#the-symmetricstate-object) object are necessary. When implementing Noise with the Disco extension, simply implement the HandshakeState object following the changes described in [section 4 of this document](#-4-modifications-to-the-handshakestate). For pre-shared symmetric keys, refer to [section 5](#5-modifications-to-pre-shared-symmetric-key); for advanced features, refer to [section 6](#6-modifications-to-advanced-features).

### 1.3. Major changes

The following list summarizes the major changes brought by this extension:

* Protocol names don't have the symmetric algorithms, but instead the version of Strobe.
* The SymmetricState and CipherState objects have been removed.
* The Handshake object makes calls to Strobe functions, affecting a unique Strobe state.
* The Handshake returns two Strobe states.

## 2. Protocol naming

The name of a Noise protocol extended with Disco follows the same convention, but replaces the symmetric cryptographic algorithms by the version of Strobe used:

```
Noise_[PATTERN]_[KEYEXCHANGE]_STROBEvX.Y.Z
```

For example, with the current version of [Strobe](https://strobe.sourceforge.io/) being STROBEv1.0.2:

```
Noise_XX_25519_STROBEv1.0.2
```

<!-- TODO: maybe change this to Noise_[PATTERN]_[KEYEXCHANGE]_STROBEvX.Y.Z_PERMUTATION -->

## 3. The StrobeState Object

### 3.1. Variables

The following variables must be set as they will be used in the protocol:

* **`R`**: The blocksize of the Strobe state (computed as `N - (2*sec)/8 - 2`, [see 4 of the Strobe specification](https://strobe.sourceforge.io/specs/#params)).
* **`TAGLEN`**: A constant specifying the size in bytes of the authentication tags generated by `SEND_AEAD`. For security reasons, `TAGLEN` must be 16 or greater.

### 3.2. Functions

A StrobeState is litteraly the state of a Strobe duplex construction. While it responds to many functions ([see Strobe's specification](https://strobe.sourceforge.io/)), only the following ones need to be implemented in order for the Disco extension to work properly:

**`InitializeStrobe(protocol_name)`**: Initialize the Strobe object with a custom protocol name.

**`KEY(key)`**: Permutes the Strobe's state and replaces the new state with the key.

**`PRF(output_len)`**: Permutes the Strobe's state and removes `output_len` bytes from the new state. Outputs the removed bytes to the caller.

**`Send_ENC(plaintext)`**: Permutes the Strobe's state and XOR the plaintext with the new state to encrypt it. The new state is replaced by the resulting ciphertext, while the resulting ciphertext is output to the caller.

**`Recv_ENC(ciphertext)`**: Permutes the Strobe's state and XOR the ciphertext with the new state to decrypt it. The new state is replaced by the ciphertext, while the resulting plaintext is output to the caller.

**`AD(additionalData)`**: Absorbs the additional data in the Strobe's state.

**`Send_MAC(output_length)`**: Permutes the Strobe's state and retrieves the next `output_length` bytes from the new state.

**`Recv_MAC(tag)`**: Permutes the Strobe's state and compare (in **constant-time**) the received tag with the next `len(tag)` bytes from the new state.

**`RATCHET(length)`**: Permutes the Strobe's state and set the next `length` bytes from the new state to zero.

The following **meta** functions:

**`meta_AD(additionalData)`**:
   XOR the additional data in the Strobe's state.

The following **AEAD** functions which are not specified in Strobe:

**`Send_AEAD(plaintext, ad)`**:
   Combines `SEND_ENC` followed with `SEND_MAC(TAGLEN)`.

**`Recv_AEAD(ciphertext, ad)`**:
   Combines `RECV_ENC` followed with `RECV_MAC(TAGLEN)`.


## 4. Modifications to the HandshakeState

The handshakeState object can be implemented following Noise's specification, except for the following points:

A `HandshakeState` object contains a `StrobeState` in place of the `SymmetricState`.

All functions responding to a handshakeState have been modified. The following modifications only affect the algorithms, for more information on each functions refer to [section 5.3 of the Noise specification](http://noiseprotocol.org/noise.html#the-handshakestate-object).

**`Initialize(handshake_pattern, initiator, prologue, s, e, rs, re)`**: 

* Derives a `protocol_name` byte sequence by combining the names for the handshake pattern and crypto functions, as specified in [Section 2 of this document](#2-protocol-naming). Calls `InitializeStrobe(protocol_name)`.
* Calls `AD(prologue)`.
* Sets the `initiator`, `s`, `e`, `rs`, and `re` variables to the corresponding arguments.
* Calls `AD()` once for each public key listed in the pre-messages from `handshake_pattern`, with the specified public key as input. If both initiator and responder have pre-messages, the initiator's public keys are hashed first.
* Sets `message_patterns` to the message patterns from `handshake_pattern`.

**`WriteMessage(payload, message_buffer)`**: 

* Fetches and deletes the next message pattern from `message_patterns`, then sequentially processes each token from the message pattern:
    - For `"e"`:  Sets `e = GENERATE_KEYPAIR()`.  Appends `e.public_key` to the buffer.  Calls `AD(e.public_key)`.
    - For `"s"`:  Appends `SEND_AEAD(s.public_key)` to the buffer.  
    - For `"ee"`: Calls `AD(DH(e, re))`.
    - For `"es"`: Calls `AD(DH(e, rs))` if initiator, `AD(DH(s, re))` if responder.
    - For `"se"`: Calls `AD(DH(s, re))` if initiator, `AD(DH(e, rs))` if responder.
    - For `"ss"`: Calls `AD(DH(s, rs))`.
* Appends `SEND_ENC(payload)` to the buffer.  
* If there are no more message patterns returns two new `StrobeState` objects by calling `Split()`.

**`ReadMessage(message, payload_buffer)`**: 

* Fetches and deletes the next message pattern from `message_patterns`, then sequentially processes each token from the message pattern:
    - For `"e"`: Sets `re` to the next `DHLEN` bytes from the message. Calls `AD(re.public_key)`.
    - For `"s"`: Sets `temp` to the next `DHLEN + 16` bytes of the message. Sets `rs` to `Recv_AEAD(temp)`.  
    - For `"ee"`: Calls `AD(DH(e, re))`.
    - For `"es"`: Calls `AD(DH(e, rs))` if initiator, `AD(DH(s, re))` if responder.
    - For `"se"`: Calls `AD(DH(s, re))` if initiator, `AD(DH(e, rs))` if responder.
    - For `"ss"`: Calls `AD(DH(s, rs))`.
* Calls `Recv_AEAD()` on the remaining bytes of the message and stores the output into `payload_buffer`.
* If there are no more message patterns returns two new `StrobeState` objects by calling `Split()`.

**`Split()`**: Returns a pair of StrobeState objects for encrypting transport messages. Executes the following steps:

* Sets `s1 = StrobeState` and `s2 = Clone(StrobeState)`.
* Calls `meta_AD("initiator")` with `s1` and `meta_AD("responder")` with `s2`.
* Calls `RATCHET(R)` with `s1` and with `s2`.
* Returns the pair (`s1`, `s2`).

**`Clone(strobe_state)`**: Returns a copy of the `strobe_state`.

## 5. Modifications to Pre-shared Symmetric Key 

PSK mode can use the `KEY()` function (instead of the original `MixKeyAndHash()` function) to mix the PSK into the Strobe state.

<!-- does this need more information? -->

## 6. Modifications to Advanced Features

### 6.1 Channel Binding

Right before calling `Split()`, a binding value could be obtained from the StrobeState by calling `PRF()`.

### 6.2 Rekey

To enable this, Strobe supports a `RATCHET()` function.

## 7. Security Considerations

The same security considerations that apply to Noise and Strobe are to be considered.


